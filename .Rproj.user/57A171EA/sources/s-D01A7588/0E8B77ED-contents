---
title: "runRstanModel"
author: "Xiuna Zhu"
date: "26/09/2021"
output: 
  html_document:
    df_print: paged
    number_sections: true
  pdf_document: 
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Load the packages

```{r message=FALSE, warning=FALSE}
source('ana_functions.R')
source("RStanCode/rstan_functions.R")
rstanmodelPath = 'RSTANMODELS'
AllExpData <- read.csv(paste0("data/AllExpData_valid.csv"))
```

```{r}
library('rstan')
options(mc.cores = parallel::detectCores()-1)
rstan_options (auto_write=TRUE)
```



##  run Baseline model (log scale)

```{r}
baselinePath = paste0(rstanmodelPath, '/models/Baseline_log')
runModelBaseline<- function(AllExpData){
  expList <- unique(AllExpData$Exp)
  rltall <- list()
  #myBaselineModel <- stan_model(model_code =stancode_Baseline, model_name = "Baseline_log")
    myBaselineModel <- stan_model(file="RStanCode/baseline_log.stan") # Create model object (generates and compiles C++ code)
  
  for (expName in expList) {
    data_exp <- AllExpData %>% dplyr::filter(valid  == 1 & Exp == expName)
    sub_exp <-  split(data_exp, data_exp$NSub) # split data for each subject
    subList <- unique(data_exp$NSub)
    for (subNo in subList) {
      rlt = funFitStanBaseline_log(sub_exp[[subNo]], myBaselineModel)
      rltall <- list.append(rltall, rlt)
    }
  }
  saveRDS(rltall, file = paste0(getwd(), "/", baselinePath, "/rlt_Baseline_log.rds"))
}
#runModelBaseline(AllExpData)
```



## merge resluts of Baseline model
```{r}
#function to merge the baseline model results
funBaselineRlt <- function(path){
  AllDat_Bayparlist <- {}
  PredY_s_list <- {}
  PredY_l_list <- {}
  NewY_s_list <- {}
  NewY_l_list <- {}
  PredY_mix_list <- {}
  NewY_mix_list <- {}
  modelResultAll <- list()
  bl_rlt = readRDS(paste0(getwd(), "/", path, "/rlt_Baseline_log.rds"))
  for (i in 1:length(bl_rlt)){
    modelResultAll <- list.append(modelResultAll,bl_rlt[[i]])
    AllDat_Bayparlist <- rbind(AllDat_Bayparlist, bl_rlt[[i]]$Baypar)
    PredY_s_list <- rbind(PredY_s_list, bl_rlt[[i]]$PredY_s_list)
    PredY_l_list <- rbind(PredY_l_list, bl_rlt[[i]]$PredY_l_list)
    NewY_l_list <- rbind(NewY_l_list, bl_rlt[[i]]$NewY_l_list)
    NewY_s_list <- rbind(NewY_s_list, bl_rlt[[i]]$NewY_s_list)
    PredY_mix_list <- rbind(PredY_mix_list, bl_rlt[[i]]$PredY_mix_list)
    NewY_mix_list <- rbind(NewY_mix_list, bl_rlt[[i]]$NewY_mix_list)
  }
  
  write.csv(AllDat_Bayparlist, paste0(getwd(), "/", path, "/AllDat_Bayparlist_BR.csv"))
  All_PredY <- rbind(PredY_s_list, PredY_l_list)
  write.csv(All_PredY, paste0(getwd(), "/", path, "/All_PredY_BR.csv"))
  write.csv(PredY_mix_list, paste0(getwd(), "/", path, "/PredY_IP.csv"))
  write.csv(NewY_mix_list, paste0(getwd(), "/", path, "/NewY_IP.csv")) 
}
funBaselineRlt(baselinePath)

```


### Definition of the function to merge rstan result data
To further uncover the underlying structure of the prior, we hypothesize that in addition to two local priors, there is a general global prior. Participants may combine both local and global priors for the final reproduction. 

There are multiple possibilities for integrating those local and global priors with the sensory inputs. For examples, the sensory input could first integrate with the local prior, and then integrate with the global prior (a hierarchical local-global model, see Figure 7B in D1 proposal). 

Our Hypothesis

* H1:  A hierarchical local-global model (LGM)
In H2, global and local priors are integrated first. That means local prior is integrated with sensory input firstly, then global prior integrates with sensory input. 
The sensory input ($D_s$) first integrates with the local prior ($P_L$) to a posterior ($D_L$), which further integrates with the global prior ($P_G$) to generate a final posterior for reproduction ($D_r$).


* H2: Global prior (dual integration model: DIM)

Both local and global priors independently integrate with the sensory inputs to generate two posteriors ($D_L$) and ($D_G$), the latter two are combined together for reproduction ($D_r$).

* H3: Integrated prior (Prior integration model:PIM)

Local integrates with global prior firstly,then the posterior of prior integration integrated with the sensory inputs to generate two posteriors ($D_L$) and ($D_G$), the latter tw are combined together for reproduction ($D_r$).


## run models on IR session data

#### run models parallely

```{r}
# source('RStanCode/rstan_log.R')
# modelPath = paste0(rstanmodelPath, '/models/log')
# 
# # function to run models on  lrz cluster parallely
# runModelparallely<- function(AllExpData, model){
#   expList <- unique(AllExpData$Exp)
#   sub_exp_dat <- list()
#   for (expName in expList) {
#     data_exp <- AllExpData %>% dplyr::filter(valid  == 1 & Exp == expName)
#     data_exp$model <- model
#     sub_exp <-  split(data_exp, data_exp$NSub) # split data for each subject
#     subList <- unique(data_exp$NSub)
#     for (subNo in subList) {
#       sub_exp_dat <- list.append(sub_exp_dat, sub_exp[[subNo]])
#     }
#   }
#   rlt <- runModelcluster(sub_exp_dat)
#   saveRDS(rlt, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,".rds"))
# }
# 
# if(runModelparallel == TRUE){
#   for(model in modellist){
#     runModelparallely(AllExpData, model)
#   }
# }
```

#### run models locally V0

```{r, message=FALSE, warning=FALSE, include=FALSE}
# source('RStanCode/rstan_log.R')  
# modelPath = paste0(rstanmodelPath, '/models/log')

# # function to run models on local computer
# modellist <- c('LGM','DIM', 'PIM', 'BPM', 'IP')#'Baseline'
# runModelonlocal<- function(AllExpData, model){
#   expList <- unique(AllExpData$Exp)
#   rltall <-list()
#   myrstanModel = NULL
#   source('RStanCode/rstan_log.R') 
#   myrstanModel  <- stan_model(model_code = Modelcode[match(model, modellist)], model_name = model)
#   for (expName in expList) {
#     data_exp <- AllExpData %>% dplyr::filter(valid == 1 & Exp == expName)
#     data_exp$model <- model
#     sub_exp <-  split(data_exp, data_exp$NSub) 
#     subList <- unique(data_exp$NSub)
#     for (subNo in subList) {
#       rlt = funFitStanSub(sub_exp[[subNo]], myrstanModel)
#       saveRDS(rlt, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,".rds"))
#       rltall <- list.append(rltall, rlt)
#     }
#   }
#   saveRDS(rltall, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,".rds"))
# }
# 
# #execute the model running
#   for(model in modellist){
#     runModelonlocal(AllExpData, model)
#   }
```


#### run models locally V1

```{r, message=FALSE, warning=FALSE, include=FALSE}
# function to run models on local computer
modelPath = paste0(rstanmodelPath, '/models/log')
modellist <- c('BPM')#'LGM','DIM', 'PIM' 'Baseline' , 'IP', 'BPM'
runModelonlocal<- function(AllExpData, model){
  expList <- unique(AllExpData$Exp)
  rltall <-list()
  myrstanModel = NULL
  myrstanModel <- stan_model(file=paste0("RStanCode/", model, "_log.stan")) 
  for (expName in expList) {
    data_exp <- AllExpData %>% dplyr::filter(valid == 1 & Exp == expName)
    data_exp$model <- model
    sub_exp <-  split(data_exp, data_exp$NSub) 
    subList <- unique(data_exp$NSub)
    for (subNo in subList) {
      subdata_mix <- sub_exp[[subNo]] %>% dplyr::filter(group == 'mixed')  # mixed groups 
      subdata_mix = mutate(subdata_mix, id = row_number())
      rlt = funFitStanSub(subdata_mix, myrstanModel, 'all', 'log')
      saveRDS(rlt, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,".rds"))
      rltall <- list.append(rltall, rlt)
    }
 }
  saveRDS(rltall, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,".rds"))
}

#execute the model running
for(model in modellist){
  runModelonlocal(AllExpData, model)
}

```


#### fit first half data sepreately V0


```{r}
# #fit first half data and second half data sepreately
# source('RStanCode/rstan_log_2part.R')  
# modelPath = paste0(rstanmodelPath, '/models/log_2part')
# 
# # function to run models on local computer
# modellist <- c('LGM','DIM', 'PIM', 'BPM')#'Baseline' , 'IP'
# runModelonlocal<- function(AllExpData, model){
#   expList <- unique(AllExpData$Exp)
#   rltall <-list()
#   myrstanModel = NULL
#   myrstanModel  <- stan_model(model_code = Modelcode[match(model, modellist)], model_name = model)
#   for (expName in expList) {
#     data_exp <- AllExpData %>% dplyr::filter(valid == 1 & Exp == expName)
#     data_exp$model <- model
#     sub_exp <-  split(data_exp, data_exp$NSub) 
#     subList <- unique(data_exp$NSub)
#     for (subNo in subList) {
#       subdata_mix <- sub_exp[[subNo]] %>% dplyr::filter(group == 'mixed')  # mixed groups 
#       subdata_mix = mutate(subdata_mix, id = row_number())
#       total = nrow(subdata_mix)
#       rlt1 = funFitStanSub(subdata_mix%>%filter(id < total/2), myrstanModel, 'part1')
#       rlt2 = funFitStanSub(subdata_mix%>%filter(id >= total/2), myrstanModel, 'part2')
#       saveRDS(rlt1, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,"_p1.rds"))
#       saveRDS(rlt2, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,"_p2.rds"))
#       rltall <- list.append(rltall, rlt1)
#       rltall <- list.append(rltall, rlt2)
#     }
#   }
#   saveRDS(rltall, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,"_2part.rds"))
# }
# 
# #execute the model running
# for(model in modellist){
#   runModelonlocal(AllExpData, model)
# }

```

#### fit first half data sepreately V1

```{r}
modelPath = paste0(rstanmodelPath, '/models/log_2part')
# function to run models on local computer
modellist <- c('LGM','DIM', 'PIM')#'Baseline' , 'IP', 'BPM'
runModelonlocal_2part<- function(AllExpData, model){
  expList <- unique(AllExpData$Exp)
  rltall <-list()
  myrstanModel = NULL
  myrstanModel <- stan_model(file=paste0("RStanCode/", model, "_log.stan")) 
  #for (expName in expList) {
  expName = "Exp3"
    data_exp <- AllExpData %>% dplyr::filter(valid == 1 & Exp == expName)
    data_exp$model <- model
    sub_exp <-  split(data_exp, data_exp$NSub) 
    subList <- unique(data_exp$NSub)
    for (subNo in subList) {
      subdata_mix <- sub_exp[[subNo]] %>% dplyr::filter(group == 'mixed')  # mixed groups 
      subdata_mix = mutate(subdata_mix, id = row_number())
      total = nrow(subdata_mix)
      rlt1 = funFitStanSub(subdata_mix%>%filter(id < total/2), myrstanModel, 'part1', 'log')
      rlt2 = funFitStanSub(subdata_mix%>%filter(id >= total/2), myrstanModel, 'part2', 'log')
      saveRDS(rlt1, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,"_p1.rds"))
      saveRDS(rlt2, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,"_p2.rds"))
      #rltall <- list.append(rltall, rlt1)
      #rltall <- list.append(rltall, rlt2)
    }
  #}
  #saveRDS(rltall, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,"_2part.rds"))
}

#execute the model running
for(model in modellist){
  runModelonlocal_2part(AllExpData, model)
}
```


### merge subject model results together 


```{r}
modelPath = paste0(rstanmodelPath, '/models/log')
modellist <- c('LGM','DIM', 'PIM')#'Baseline' , 'IP', 'BPM'
mergeModelRlt<- function(model){
  rltall <-list()
  for (expName in c('Exp1', 'Exp2')) {
    subList <- 1:16
    for (subNo in subList) {
      rlt = readRDS(file = paste0(getwd(), "/", modelPath, "/rlt/rlt_",subNo,"_", expName,"_", model,".rds"))
      rltall <- list.append(rltall, rlt)
    }
  }
  saveRDS(rltall, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,".rds"))
}
#mergeModelRlt('LGM')
```


```{r}
#modelPath = paste0(rstanmodelPath, '/models/log_2part')
modelPath = paste0(rstanmodelPath, '/models/linear_2part')
mergeModelRlt_2part<- function(model){
  rltall <-list()
  for (expName in c('Exp1', 'Exp2')) {
    subList <- 1:16
    for (subNo in subList) {
      rlt1 = readRDS(file = paste0(getwd(), "/", modelPath, "/rlt/subModelRlt/rlt_",subNo,"_", expName,"_", model,"_p1.rds"))
      rlt1$Baypar$part = 'part1'
      rlt2 = readRDS(file = paste0(getwd(), "/", modelPath, "/rlt/subModelRlt/rlt_",subNo,"_", expName,"_", model,"_p2.rds"))
      rlt2$Baypar$part = 'part2'
      rltall <- list.append(rltall, rlt1)
      rltall <- list.append(rltall, rlt2)
    }
  }
  saveRDS(rltall, file = paste0(getwd(), "/", modelPath, "/rlt/rlt_", model,"_2part.rds"))
}
#mergeModelRlt_2part('LGM')
```
