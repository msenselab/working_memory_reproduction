###########################################################################
# Hierarchical Bayesian modeling (logarithmic encoding version)
# for manuscript: Duration reproduction under memory pressure: Modeling the roles of visual memory load in duration encoding and reproduction
############################################################################
library(parallel)
library(doParallel)
library(tidyverse)
library(rstan)
library(rlist)
library(reshape2)
library(loo)
#library(readr)

# flag for running rstan model and saving the results
runModellocally = FALSE
# flag for running rstan model on  lrz cluster parallely
runModelparallel = FALSE
# flag for compile models
compileModels = FALSE
# model version
modelversion = 'log_rstan'


### definition of rstan model
mystancode <- '
// Logarithmic encoding model
functions {
real mu_normal(real mu, real variance){
  return(exp(mu+ variance *0.5));
}


real variance_normal(real mu, real variance){
  return((exp(variance)-1)*exp(2*mu + variance));
}

matrix predictor_rng(real[] x, int[] size, real ks, real ls, real kr, real sig_s2, real sigma_pr2,  real mu_pr_log, real sig_mn2, real[] par) {
vector[num_elements(x)] predY;    //predication of RP generated by model
real sig_sm2;   // sigma^2 of posterior
vector[num_elements(x)] wp_pr;    //weight of prior
vector[num_elements(x)] mu_sm;
vector[num_elements(x)] mu_post;      //mean of reproduction
vector[num_elements(x)] mu_r_log;      //mean of reproduction in logarithmic scale
vector[num_elements(x)] mu_r;      //mean of reproduction
real sig_wm2;   // sigma^2 of sensory measurement
vector[num_elements(x)] sig_r;     //sigma of RP 
vector[num_elements(x)] log_lik;

for (i in 1:num_elements(x))
{
   if(par[1] == 1){
    mu_sm[i] = log(x[i])- ks*(size[i]);
  }
  else{
    mu_sm[i] = log(x[i]);
  }
  
  if(par[2] == 1){
   sig_sm2 =  sig_s2 + ls*(size[i]);
  }else {
   sig_sm2 =  sig_s2;
  }
 
  wp_pr[i] = sig_sm2 /(sig_sm2 + sigma_pr2); 
  mu_post[i] = wp_pr[i]*mu_pr_log +(1-wp_pr[i]) *mu_sm[i]; 
  sig_wm2 = (sigma_pr2 *sig_sm2)/(sigma_pr2 + sig_sm2);
  if(par[3] == 1){
      mu_r_log[i] = mu_post[i] + kr*(size[i]);
   }else{
      mu_r_log[i] = mu_post[i];
   }
   
  mu_r[i] = mu_normal(mu_r_log[i], sig_wm2);
  sig_r[i] =  sqrt(variance_normal(mu_r_log[i], sig_wm2) +sig_mn2/x[i]);
  predY[i] = normal_rng(mu_r[i], sig_r[i]); 
  log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
}

return(append_col(append_col(append_col(wp_pr, mu_r), append_col(sig_r, predY)), append_col(mu_post,log_lik)));
}

}

// The input data 
data {
int<lower=0> n;
real y[n];   //measured reproductive duration 
real x[n];   //stimulus duration
int WMSize[n];
int WMSize_new[423];       //new wm task size
real xnew[423];  //new target duration
real par[3]; // ks, ls, kr
}

// The parameters accepted by the model
parameters {  
//hyperparameters
real<lower=0> sig_s2;  
real<lower=0> ks;  // scale factor of mu_sm in production phase 
real<lower=0> ls;  // scale factor of sig_sm in production phase 
real<lower=0> kr;  // scale factor of mu_r in reproduction phase 
real mu_pr_log;  // mean of internal prior in log scale
real<lower=0> sig_pr2_log;  // sigma^2 of prior in log scale
real<lower=0> sig_mn2; //square of sigma of motor noise caused by WM task
} 

transformed parameters {
}

model {
real mu_sm[n];      //
real sig_sm2;   // sigma^2 of sensory measuremnet
real sig_wm2;   // sigma^2 of posterior
real mu_r_log[n];   // sigma^2 of posterior
real mu_r[n];   // sigma^2 of posterior
real wp[n];        //weight of prior
real mu_post[n];      //mean of reproduction
real sig_r[n];   // sigma^2 of posterior
real sig_wm_hat2[n]; 
ks ~ cauchy(0, 1);
ls ~ cauchy(0, 1);
kr ~ cauchy(0, 1);
mu_pr_log ~ normal(0, 1);
sig_mn2 ~ cauchy(0, 1);
sig_s2 ~ cauchy(0, 1);
sig_pr2_log ~ cauchy(0, 1);


for (i in 1:n)
{
  if(par[1] == 1){
    mu_sm[i] = log(x[i])- ks*(WMSize[i]);
  }
  else{
    mu_sm[i] = log(x[i]);
  }
  
  if(par[2] == 1){
   sig_sm2 =  sig_s2 + ls*(WMSize[i]);
  }else {
   sig_sm2 =  sig_s2;
  }
 
  wp[i] = sig_sm2 /(sig_sm2 + sig_pr2_log); 
  mu_post[i] = wp[i]*mu_pr_log +(1-wp[i]) *mu_sm[i]; 
 sig_wm2 = sig_pr2_log *sig_sm2/(sig_pr2_log + sig_sm2);
   if(par[3] == 1){
      mu_r_log[i] = mu_post[i] + kr*(WMSize[i]);
   }else{
      mu_r_log[i] = mu_post[i];
   }
  mu_r[i] = mu_normal(mu_r_log[i], sig_wm2);
  sig_r[i] =  sqrt(variance_normal(mu_r_log[i], sig_wm2) +sig_mn2/x[i]);
  target += normal_lpdf(y[i] | mu_r[i], sig_r[i]); 
 }
}

generated quantities {
matrix[n,6] predRP;
matrix[423,6] ynew;
vector[n] log_lik;
real log_lik_sum;
predRP = predictor_rng(x, WMSize, ks, ls, kr, sig_s2, sig_pr2_log, mu_pr_log, sig_mn2, par);
ynew = predictor_rng(xnew, WMSize_new, ks, ls, kr, sig_s2, sig_pr2_log, mu_pr_log, sig_mn2, par);
log_lik =  col(predRP, 6);
//log_lik = predictor_log_lik_rng(x, WMSize, ks, ls, kr, sig_s2, sig_pr2_log, mu_pr_log, sig_mn2, par);
log_lik_sum =  sum(log_lik);
}'



## The definition of the function to run Rstan model locally
## when parameter noEffect is true marks all data fits with exp1 model 
funFitStan <- function(subdat, myrstanModel, noEffect){
  # subdat <-sub_exp[[1]]
  library(rstan)
  library(tidyverse)
  library(dplyr)
  library(loo)
  
  modelname <-  unique(subdat$model)
  subNo <- unique(subdat$NSub)
  expName <- unique(subdat$Exp)
  print(paste0('Start run rstan model ', modelname,' on Subject No.',subNo, ' in ', expName))
  
  subdat$WMSize = as.numeric(subdat$WMSize)
  subdat$WMSize1 = (subdat$WMSize +1)/2
  n = length(subdat$repDur)
  xnew <- rep(seq(0.4,1.8,0.01), 3)
  WMSizenew <- c(rep(1,141), rep(2,141), rep(3,141))
  
  par = c(0,0,0)
  if(!noEffect){
    if(modelname == 'Exp4'){
      par = c(1,1,1)
    }
    
    if( modelname == 'Exp2'){
      par = c(1,1,0)
    }
    
    if(modelname == 'Exp3'){
      par = c(0,0,1)
    }
  }
 
  
  stan_data = list( y= subdat$repDur, n=n, x = subdat$curDur,
                    WMSize = subdat$WMSize1,
                    xnew = xnew, WMSize_new = WMSizenew,  par = par)  #data passed to stan
  
  PredY_list <- subdat[c('NSub','curDur', 'repDur','Exp','WMSize', 'model')]
  NewY_list <- data.frame(cbind(xnew, WMSizenew))
  colnames(NewY_list)  <-c("curDur", "WMSize")
  NewY_list$NSub =subNo
  NewY_list$Exp = expName
  NewY_list$model = modelname
  
  myinits <- list()
  parameters <- {}
  parameters <- c("sig_s2","ks", "ls", "kr",  "mu_pr_log", "sig_mn2",  "sig_pr2_log", "predRP", "ynew", "log_lik", "log_lik_sum") 
  init_mem1 <-  list(sig_s2=0.1, ks= 0.1, ls= 0.1, kr= 0.1, mu_pr_log= 0, sig_pr2_log = 0.1, sig_mn2 = 0.1)
  myinits <- list(init_mem1, init_mem1, init_mem1, init_mem1)
  
  # fit models
  subfit <- sampling(myrstanModel, 
                     data = stan_data,
                     init=myinits,
                     iter=4000,
                     chains=4,
                     thin=1,
                     control = list(adapt_delta = 0.84,
                                    max_treedepth = 10))
  
  log_lik_rlt <- extract_log_lik(subfit)
  loo_1 <- loo(log_lik_rlt)
  waic = waic(log_lik_rlt)
  
  fitpar <- summary(subfit, pars = parameters)$summary
  list_of_draws <- rstan::extract(subfit, pars = parameters)
  
  
  log_lik_list <- list_of_draws$log_lik
  log_lik <-0 #matrix(rep(0, n, 6), nrow = n, ncol = 6)
  
  for (j in 1:n){
    log_lik[j] <-  mean(log_lik_list[,j] )
  }
  log_lik_sum <- sum(log_lik)
  log_lik_mean <- mean(log_lik)
  
  sig_s2 =  mean(list_of_draws$sig_s2)
  ks = 0
  ls = 0
  kr = 0
  sig_mn2 = mean(list_of_draws$sig_mn2)
  
  
  if(modelname == 'Exp4'| modelname == 'Exp2'){
    ks =  mean(list_of_draws$ks)
    ls =  mean(list_of_draws$ls)
  }
  
  if(modelname == 'Exp4'| modelname == 'Exp3'){
    kr=  mean(list_of_draws$kr)
  }
  
  
  mu_pr_log = mean(list_of_draws$mu_pr_log)
  sig_pr2_log =  mean(list_of_draws$sig_pr2_log)
  
  pred_y <- matrix(rep(0, n, 6), nrow = n, ncol = 6)
  predRP_list <- list_of_draws$predRP
  
  for (i in 1:6){
    for (j in 1:n){
      pred_y[j,i] <-  mean(predRP_list[,j,i] )
    }
  }
  colnames(pred_y)  <-c("wp", "mu_r", "sig_r", "predY", "mu_post", "log_lik")
  PredY_list <- cbind(PredY_list, pred_y)
  
  y_new <- matrix(rep(0, 423, 6), nrow = 423, ncol = 6)
  YNew_list <- list_of_draws$ynew
  for (i in 1:6){
    for (j in 1:423){
      y_new[j,i] <-  mean(YNew_list[,j,i] )
    }
  }
  colnames(y_new)  <-c("wp", "mu_r", "sig_r", "predY", "mu_post", "log_lik")
  NewY_list = cbind(NewY_list, y_new)
  
  Baypar = data.frame(
    NSub = subNo,
    Exp = expName,
    model = modelname,
    sig_s2 = sig_s2,
    ks = ks,
    ls = ls,
    kr = kr,
    sig_mn2 =sig_mn2,
    mu_pr_log = mu_pr_log,  
    sig_pr2_log = sig_pr2_log,
    looic = loo_1$looic,
    p_loo = loo_1$p_loo,
    elpd_loo = loo_1$elpd_loo,
    se_looic = loo_1$se_looic,
    se_p_loo = loo_1$se_p_loo,
    waic = waic$waic,
    p_waic =waic$p_waic,
    se_waic = waic$se_waic,
    se_p_waic = waic$se_p_waic,
    elpd_waic = waic$elpd_waic,
    se_waic = waic$se_waic,
    log_lik_sum = log_lik_sum,
    log_lik_mean = log_lik_mean
  )
  
  NewY_list[which(NewY_list$WMSize== 3),"WMSize"] = 5
  NewY_list[which(NewY_list$WMSize== 2),"WMSize"] = 3
  
  return(list("Baypar" = Baypar, "PredY_list" = PredY_list, "NewY_list" = NewY_list, "loo" = loo_1,  "waic" = waic))
}


#Parallel compute parameters for each subject each model
runModelcluster<- function(sub_exp_dat){
  cl <- makeCluster(detectCores() - 1)
  clusterEvalQ(cl, {library(dplyr, rstan) })
  clusterExport(cl, c('funFitStan'))
  t0 = proc.time()
  resultlist <- clusterMap(cl, funFitStan, sub_exp_dat)
  stopCluster(cl)
  print(proc.time()-t0)
  return(resultlist)
}
