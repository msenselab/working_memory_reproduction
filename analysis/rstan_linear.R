###########################################################################
# This .r file provides 3 stan models for 3 experiments
############################################################################
library(parallel)
library(doParallel)
library(tidyverse)
library(rstan)
library(rlist)
library(reshape2)
library(loo)
#library(readr)

# flag for running rstan model and saving the results
runModellocally = FALSE
# flag for running rstan model on  lrz cluster parallely
runModelparallel = FALSE
# flag for compile models
compileModels = FALSE
# model version
modelversion = 'linear'

## The definition of the function to run Rstan model locally
funFitStan <- function(subdat){
  # subdat <-sub_exp[[1]]
  library(rstan)
  library(tidyverse)
  library(dplyr)
  library(loo)
  ### definition of rstan model for experiment1
  mystancode_Exp1 <- '
// Logarithmic encoding model for experiment 1
functions {
 vector predictor_log_lik_rng(real[] x, int[] size, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i];
      sig_sm2[i] =  square(sig_s);
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]; //mu_X_i
      predY[i] = normal_rng(mu_r[i], sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(log_lik);
 }
  
  
  matrix predictor_rng(real[] x, int[] size, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i];
      sig_sm2[i] =  square(sig_s);
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]; //mu_X_i
      predY[i] = normal_rng(mu_r[i], sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(append_col(append_col(append_col(wp_pr, mu_r), append_col(sig_r, predY)), append_col(sig_wm2, log_lik)));
  }
}

// The input data 
data {
  int<lower=0> n;
  real<lower=0> y[n];   //measured reproductive duration 
  real<lower=0> x[n];   //stimulus duration
  int wmsize[n];
  int wmsize_new[423];       //new wm task size
  real<lower=0> xnew[423];  //new target duration
}

// The parameters accepted by the model. Our model
// accepts 7 parameters
parameters {  
  //hyperparameters
  real sig_s;   //Weber Fraction 
  real mu_pr;  // mean of internal prior 
  real<lower=0,upper=4> sig_pr2;  // sigma^2 of prior
  real<lower=0,upper=4> sig_mn; //square of sigma of motor noise caused by WM task
} 

model {
  real mu_sm[n];      //
  real sig_sm2[n];   // sigma^2 of sensory measuremnet
  real sig_wm2[n];   // sigma^2 of posterior
  real wp[n];        //weight of prior
  mu_pr ~ normal(0, 1);
  sig_s ~ cauchy(0, 1);
  
  for (i in 1:n)
  {
      mu_sm[i] = x[i];
      sig_sm2[i] =  square(sig_s);
      wp[i] = sig_sm2[i] /(sig_sm2[i] + sig_pr2); 
      sig_wm2[i] = sig_pr2 *sig_sm2[i]/(sig_pr2 + sig_sm2[i]);
      y[i] ~ normal(wp[i]*mu_pr +(1-wp[i]) *mu_sm[i], sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i])); 
  }
}

generated quantities {
  matrix[n,6] predRP;
  matrix[423,6] ynew;
  vector[n] log_lik;
  real log_lik_sum;
  predRP = predictor_rng(x, wmsize, sig_s, sig_pr2, mu_pr, sig_mn);
  ynew = predictor_rng(xnew, wmsize_new, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik = predictor_log_lik_rng(x, wmsize, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik_sum =  sum(log_lik);
}'
myrstanModel_Exp1 <- stan_model(model_code = mystancode_Exp1, model_name = 'Exp1')


### Logarithmic encoding model for experiment4
mystancode_Exp4 <- '
functions {
 vector predictor_log_lik_rng(real[] x, int[] size, real ks, real ls, real kr, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i]*(1-ks*size[i]);
      sig_sm2[i] =  square(sig_s * (1+ls*size[i]));
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  (wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]) *(1 + kr*size[i]); //mu_X_i
      predY[i] = normal_rng(mu_r[i], sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(log_lik);
 }
  
  
matrix predictor_rng(real[] x, int[] size, real ks, real ls, real kr, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i]*(1- ks*size[i]);
      sig_sm2[i] =  square(sig_s * (1+ls*size[i]));
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  (wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]) *(1+ kr*size[i]); //mu_X_i
      predY[i] = normal_rng(mu_r[i], sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(append_col(append_col(append_col(wp_pr, mu_r), append_col(sig_r, predY)), append_col(sig_wm2, log_lik)));
  }
}

// The input data 
data {
  int<lower=0> n;
  real<lower=0> y[n];   //measured reproductive duration 
  real<lower=0> x[n];   //stimulus duration
  int wmsize[n];
  int wmsize_new[423];       //new wm task size
  real<lower=0> xnew[423];  //new target duration
}

// The parameters accepted by the model. Our model
// accepts 7 parameters
parameters {  
  //hyperparameters
  real sig_s;   //Weber Fraction 
  real mu_pr;  // mean of internal prior 
  real<lower=0,upper=4> sig_pr2;  // sigma^2 of prior
  real<lower=0,upper=4> sig_mn; //square of sigma of motor noise caused by WM task
  real<lower=0, upper=1> ks;  // scale factor of mu_sm in production phase 
  real<lower=0, upper=1> ls;  // scale factor of sig_sm in production phase 
  real<lower=0, upper=1> kr;  // scale factor of mu_r in reproduction phase 
} 

model {
  real mu_sm[n];      //
  real sig_sm2[n];   // sigma^2 of sensory measuremnet
  real sig_wm2[n];   // sigma^2 of posterior
  real wp[n];        //weight of prior
  ks ~ normal(0, 1);
  ls ~ cauchy(0, 1);
  kr ~ normal(0, 1);
  mu_pr ~ normal(0, 1);
  sig_s ~ cauchy(0, 1);
  
  for (i in 1:n)
  {
      mu_sm[i] = x[i]*(1-ks*wmsize[i]);
      sig_sm2[i] =  square(sig_s * (1+ ls*wmsize[i]));
      wp[i] = sig_sm2[i] /(sig_sm2[i] + sig_pr2); 
      sig_wm2[i] = sig_pr2 *sig_sm2[i]/(sig_pr2 + sig_sm2[i]);
      y[i] ~ normal((wp[i]*mu_pr +(1-wp[i]) *mu_sm[i])*(1 + kr*wmsize[i]), sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i])); 
  }
}

generated quantities {
  matrix[n,6] predRP;
  matrix[423,6] ynew;
  vector[n] log_lik;
  real log_lik_sum;
  predRP = predictor_rng(x, wmsize, ks, ls, kr, sig_s, sig_pr2, mu_pr, sig_mn);
  ynew = predictor_rng(xnew, wmsize_new, ks, ls, kr, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik = predictor_log_lik_rng(x, wmsize, ks, ls, kr, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik_sum =  sum(log_lik);
}
'
myrstanModel_Exp4 <- stan_model(model_code = mystancode_Exp4, model_name = 'Exp4')


mystancode_Exp3 <- '
// Logarithmic encoding model for experiment3
// Logarithmic encoding model for experiment 4
functions {
 vector predictor_log_lik_rng(real[] x, int[] size, real kr, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i];
      sig_sm2[i] =  square(sig_s);
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  (wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i])* (1 + kr*size[i]); //mu_X_i
      predY[i] = normal_rng(mu_r[i] , sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(log_lik);
 }
  
  
matrix predictor_rng(real[] x, int[] size, real kr, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i];
      sig_sm2[i] =  square(sig_s);
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  (wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]) * (1 + kr*size[i]); //mu_X_i
      predY[i] = normal_rng(mu_r[i], sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(append_col(append_col(append_col(wp_pr, mu_r), append_col(sig_r, predY)), append_col(sig_wm2, log_lik)));
  }
}

// The input data 
data {
  int<lower=0> n;
  real<lower=0> y[n];   //measured reproductive duration 
  real<lower=0> x[n];   //stimulus duration
  int wmsize[n];
  int wmsize_new[423];       //new wm task size
  real<lower=0> xnew[423];  //new target duration
}

// The parameters accepted by the model. Our model
// accepts 7 parameters
parameters {  
  //hyperparameters
  real sig_s;   //Weber Fraction 
  real mu_pr;  // mean of internal prior 
  real<lower=0,upper=4> sig_pr2;  // sigma^2 of prior
  real<lower=0,upper=4> sig_mn; //square of sigma of motor noise caused by WM task
  real<lower=0, upper=1> kr;  // scale factor of mu_r in reproduction phase 
} 

model {
  real mu_sm[n];      //
  real sig_sm2[n];   // sigma^2 of sensory measuremnet
  real sig_wm2[n];   // sigma^2 of posterior
  real wp[n];        //weight of prior
  kr ~ normal(0, 1);
  mu_pr ~ normal(1, 1);
  sig_s ~ cauchy(0, 1);
  
  for (i in 1:n)
  {
      mu_sm[i] = x[i] ;
      sig_sm2[i] =  square(sig_s);
      wp[i] = sig_sm2[i] /(sig_sm2[i] + sig_pr2); 
      sig_wm2[i] = sig_pr2 *sig_sm2[i]/(sig_pr2 + sig_sm2[i]);
      y[i] ~ normal((wp[i]*mu_pr +(1-wp[i]) *mu_sm[i])* (1+ kr*wmsize[i]), sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i])); 
  }
}

generated quantities {
  matrix[n,6] predRP;
  matrix[423,6] ynew;
  vector[n] log_lik;
  real log_lik_sum;
  predRP = predictor_rng(x, wmsize, kr, sig_s, sig_pr2, mu_pr, sig_mn);
  ynew = predictor_rng(xnew, wmsize_new, kr, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik = predictor_log_lik_rng(x, wmsize, kr, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik_sum =  sum(log_lik);
}'
myrstanModel_Exp3 <- stan_model(model_code = mystancode_Exp3, model_name = 'Exp3')



mystancode_Exp2 <- '
// Logarithmic encoding model for experiment2
functions {
 vector predictor_log_lik_rng(real[] x, int[] size, real ks, real ls, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i]*(1 - ks*size[i]);
      sig_sm2[i] =  square(sig_s * (1+ls*size[i]));
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]; //mu_X_i
      predY[i] = normal_rng(mu_r[i] , sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(log_lik);
 }
  
  
matrix predictor_rng(real[] x, int[] size, real ks, real ls, real sig_s, real sigma_pr2,  real mu_prior, real sig_mn) {
    vector[num_elements(x)] predY;    //predication of RP generated by model
    vector[num_elements(x)] mu_sm; 
    vector[num_elements(x)] sig_sm2;   // sigma^2 of posterior
    vector[num_elements(x)] wp_pr;    //weight of prior
    vector[num_elements(x)] mu_r;      //mean of reproduction
    vector[num_elements(x)] sig_wm2;   // sigma^2 of sensory measurement
    vector[num_elements(x)] sig_r;     //sigma of RP 
    vector[num_elements(x)] log_lik;
    
    for (i in 1:num_elements(x))
    {
      mu_sm[i] = x[i]*(1 - ks*size[i]);
      sig_sm2[i] =  square(sig_s * (1+ls*size[i]));
      wp_pr[i] = sig_sm2[i] /(sig_sm2[i] + sigma_pr2); 
      sig_wm2[i] = sigma_pr2 *sig_sm2[i]/(sigma_pr2 + sig_sm2[i]);
      sig_r[i] = sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i]);
      mu_r[i] =  wp_pr[i]*mu_prior +(1-wp_pr[i]) *mu_sm[i]; //mu_X_i
      predY[i] = normal_rng(mu_r[i], sig_r[i]); 
      log_lik[i] = normal_lpdf(predY[i]|mu_r[i], sig_r[i]);
    }
   return(append_col(append_col(append_col(wp_pr, mu_r), append_col(sig_r, predY)), append_col(sig_wm2, log_lik)));
  }
}

// The input data 
data {
  int<lower=0> n;
  real<lower=0> y[n];   //measured reproductive duration 
  real<lower=0> x[n];   //stimulus duration
  int wmsize[n];
  int wmsize_new[423];       //new wm task size
  real<lower=0> xnew[423];  //new target duration
}

// The parameters accepted by the model. Our model
// accepts 7 parameters
parameters {  
  //hyperparameters
  real sig_s;   //Weber Fraction 
  real mu_pr;  // mean of internal prior 
  real<lower=0,upper=4> sig_pr2;  // sigma^2 of prior
  real<lower=0,upper=4> sig_mn; //square of sigma of motor noise caused by WM task
  real<lower=0, upper=1> ks;  // scale factor of mu_sm in production phase 
  real<lower=0, upper=1> ls;  // scale factor of sig_sm in production phase 
} 

model {
  real mu_sm[n];      //
  real sig_sm2[n];   // sigma^2 of sensory measuremnet
  real sig_wm2[n];   // sigma^2 of posterior
  real wp[n];        //weight of prior
  ks ~ normal(0, 1);
  ls ~ cauchy(0, 1);
  mu_pr ~ normal(1, 1);
  sig_s ~ cauchy(0, 1);
  
  for (i in 1:n)
  {
      mu_sm[i] = x[i] *(1 - ks*wmsize[i]);
      sig_sm2[i] =  square(sig_s * (1 + ls*wmsize[i]));
      wp[i] = sig_sm2[i] /(sig_sm2[i] + sig_pr2); 
      sig_wm2[i] = sig_pr2 *sig_sm2[i]/(sig_pr2 + sig_sm2[i]);
      y[i] ~ normal(wp[i]*mu_pr +(1-wp[i]) *mu_sm[i], sqrt(sig_mn*sig_mn/x[i] + sig_wm2[i])); 
  }
}

generated quantities {
  matrix[n,6] predRP;
  matrix[423,6] ynew;
  vector[n] log_lik;
  real log_lik_sum;
  predRP = predictor_rng(x, wmsize,  ks, ls, sig_s, sig_pr2, mu_pr, sig_mn);
  ynew = predictor_rng(xnew, wmsize_new,  ks, ls, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik = predictor_log_lik_rng(x, wmsize, ks, ls, sig_s, sig_pr2, mu_pr, sig_mn);
  log_lik_sum =  sum(log_lik);
}'
myrstanModel_Exp2 <- stan_model(model_code = mystancode_Exp2, model_name = 'Exp2')


modelname <-  unique(subdat$model)
subNo <- unique(subdat$NSub)
expName <- unique(subdat$Exp)
print(paste0('Start run rstan model ', modelname,' on Subject No.',subNo, ' in ', expName))

subdat$WMSize = as.numeric(subdat$WMSize)
subdat$WMSize1 = (subdat$WMSize +1)/2
n = length(subdat$repDur)
x = subdat$curDur
xnew <- rep(seq(0.4,1.8,0.01), 3)
WMSizenew <- c(rep(1,141), rep(2,141), rep(3,141))

stan_data = list( y=subdat$repDur, n=n, x = subdat$curDur,
                  wmsize = subdat$WMSize1,
                  xnew = xnew, wmsize_new = WMSizenew)  #data passed to stan

PredY_list <- subdat[c('NSub','curDur', 'repDur','Exp','WMSize', 'model')]
NewY_list <- data.frame(cbind(xnew, WMSizenew))
colnames(NewY_list)  <-c("curDur", "WMSize")
NewY_list$NSub =subNo
NewY_list$Exp = expName
NewY_list$model = modelname


myinits <- list()
parameters <- {}
init_mem1 <-  list(sig_s=1, mu_pr=1, sig_pr2 = 0.5, sig_mn = 0.1)
myrstanModel = myrstanModel_Exp1
if(modelname == 'Exp1' ){#remove ks, ls, kr
  myrstanModel <- myrstanModel_Exp1
  parameters <- c("sig_s", "mu_pr", "sig_mn", "sig_pr2", "predRP", "ynew", "log_lik", "log_lik_sum") 
  init_mem1 <-  list(sig_s=1, mu_pr=1, sig_pr2 = 0.5, sig_mn = 0.1)
}
if(modelname == 'Exp4' ){
  myrstanModel <- myrstanModel_Exp4
  parameters <- c("sig_s","ks", "ls", "kr", "mu_pr", "sig_mn", "sig_pr2", "predRP", "ynew", "log_lik", "log_lik_sum") 
  init_mem1 <-  list(sig_s=1, ks= 0.1, ls= 0.1, kr= 0.1, mu_pr=1, sig_pr2 = 0.5, sig_mn = 0.1)
}

if (modelname == 'Exp3'){ #remove "ks", "ls", 
  myrstanModel <- myrstanModel_Exp3
  parameters <- c("sig_s", "kr", "sig_pr2", "mu_pr","sig_mn", "predRP",  "ynew", "log_lik", "log_lik_sum") #V1
  init_mem1 <-  list(sig_s=1, kr= 0.1, mu_pr=1, sig_pr2 = 0.5, sig_mn = 0.1)
}
if(modelname == 'Exp2'){ #remove kr
  myrstanModel <- myrstanModel_Exp2
  parameters <- c("sig_s","ks", "ls", "mu_pr", "sig_mn", "sig_pr2", "predRP", "ynew", "log_lik", "log_lik_sum") #V1
  init_mem1 <-  list(sig_s=1, ks= 0.1, ls= 0.1, mu_pr=1, sig_pr2 = 0.5, sig_mn = 0.1)
}
myinits <- list(init_mem1,init_mem1, init_mem1,init_mem1)

# fit models (M1)
subfit <- sampling(myrstanModel, 
                   data = stan_data,
                   init=myinits,
                   iter=8000,
                   chains=4,
                   thin=1,
                   control = list(adapt_delta = 0.99,
                                  max_treedepth = 15))


log_lik_rlt <- extract_log_lik(subfit)
loo_1 <- loo(log_lik_rlt)
waic = waic(log_lik_rlt)

# pairs(subfit, pars = c("sig_s", "lp__","mu_pr","ks","ls","kr"))
# pairs(subfit, pars = c("sig_s", "lp__","mu_pr","ks","ls","sig_m2", "sig_pr2")) #exp4
# pairs(subfit, pars = c("sig_s", "lp__","mu_pr","kr","sig_m2", "sig_pr2")) #exp3
# pairs(subfit, pars = c("mu_pr","ks","ls","kr"))
fitpar <- summary(subfit, pars = parameters)$summary
list_of_draws <- rstan::extract(subfit, pars = parameters)


log_lik_list <- list_of_draws$log_lik
log_lik <-0 #matrix(rep(0, n, 6), nrow = n, ncol = 6)

for (j in 1:n){
  log_lik[j] <-  mean(log_lik_list[,j] )
}
log_lik_sum <- sum(log_lik)
log_lik_mean <- mean(log_lik)

sig_s =  mean(list_of_draws$sig_s)
ks= 0
ls = 0
kr = 0
sig_mn = mean(list_of_draws$sig_mn)


if(modelname == 'Exp4'| modelname == 'Exp2'){
  ks =  mean(list_of_draws$ks)
  ls =  mean(list_of_draws$ls)
}

if(modelname == 'Exp4'| modelname == 'Exp3'){
  kr=  mean(list_of_draws$kr)
}


#comment following lines for V1
mu_pr = mean(list_of_draws$mu_pr)
sig_pr2 =  mean(list_of_draws$sig_pr2)

pred_y <- matrix(rep(0, n, 6), nrow = n, ncol = 6)
predRP_list <- list_of_draws$predRP
#print(dim(predRP_list))
for (i in 1:6){
  for (j in 1:n){
    pred_y[j,i] <-  mean(predRP_list[,j,i] )
  }
}
colnames(pred_y)  <-c("wp", "mu_r", "sig_r", "predY", "sig_wm2", "log_lik")
PredY_list <- cbind(PredY_list, pred_y)

y_new <- matrix(rep(0, 423, 6), nrow = 423, ncol = 6)
YNew_list <- list_of_draws$ynew
for (i in 1:6){
  for (j in 1:423){
    y_new[j,i] <-  mean(YNew_list[,j,i] )
  }
}
colnames(y_new)  <-c("wp", "mu_r", "sig_r", "predY", "sig_wm2", "log_lik")
NewY_list = cbind(NewY_list, y_new)

Baypar = data.frame(
  Nsub = subNo,
  Exp = expName,
  model = modelname,
  sig_s = sig_s,
  ks = ks,
  ls = ls,
  kr = kr,
  sig_mn =sig_mn,
  mu_pr = mu_pr,  #comment this lines for V1
  sig_pr2 = sig_pr2,
  looic = loo_1$looic,
  p_loo = loo_1$p_loo,
  elpd_loo = loo_1$elpd_loo,
  se_looic = loo_1$se_looic,
  se_p_loo = loo_1$se_p_loo,
  waic = waic$waic,
  p_waic =waic$p_waic,
  se_waic = waic$se_waic,
  se_p_waic = waic$se_p_waic,
  elpd_waic = waic$elpd_waic,
  se_waic = waic$se_waic,
  log_lik_sum = log_lik_sum,
  log_lik_mean = log_lik_mean
)

NewY_list[which(NewY_list$WMSize== 3),"WMSize"] = 5
NewY_list[which(NewY_list$WMSize== 2),"WMSize"] = 3

return(list("Baypar" = Baypar, "PredY_list" = PredY_list, "NewY_list" = NewY_list, "loo" = loo_1,  "waic" = waic))
}


#Parallel compute parameters for each subject each model
runModelcluster<- function(sub_exp_dat){
  cl <- makeCluster(detectCores() - 1)
  clusterEvalQ(cl, {library(dplyr, rstan) })
  clusterExport(cl, c('funFitStan'))
  t0 = proc.time()
  resultlist <- clusterMap(cl, funFitStan, sub_exp_dat)
  stopCluster(cl)
  print(proc.time()-t0)
  return(resultlist)
}
